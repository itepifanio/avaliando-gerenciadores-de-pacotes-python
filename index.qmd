---
title: "Gerenciadores de pacotes Python: Indo além do pip install"
author: "Ítalo Epifânio"
format:
  revealjs:
    slide-number: true
    preview-links: auto
    css: styles.css
---

## Quem sou eu {.smaller}

::: {.fragment}
- Norte-rio-grandense da trombinha do elefante
![](images/mapa-pau-dos-ferros.png){.absolute top=0 right=0 width=350 height=238}
:::
::: {.fragment}
- Cientista da Computação
- Machine Learning Engineer
:::

::: {.fragment}
- Entusiasta de comunidades de tecnologia open source
![](images/grupyrn.png){.absolute top=250 right=0}
:::

## Sumário

- Pip install nem sempre basta, e escolher a ferramenta certa é desafiador
- Por que Python tem diversas ferramentas para gerenciar dependências?
- Estudo de caso na hora de escolher uma ferramenta
- Apresentação de algumas delas

## O que é ferramenta e o que é pokemon?

::: {.columns}

::: {.column width="50%"}
- Hatch
- UV
- Togepy
- Pipenv
- pip-tools
- Poetry
:::

::: {.column width="50%"}
- PDM
- Rhyhorn
- Rye
- Pyflow
- Pixi
- Mamba
:::

:::

## Pokemons

::: {layout-ncol=2}

![Togepi](images/togepi.png){#togepi}

![Rhyhorn](images/rhyhorn.jpg){#rhyhorn}

::: footer
Acertou quem disse Togepy e Rhyhorn :)
:::

:::

## Ferramentas{.smaller}

![Imagem do blog post da [Anna Lena Popkes](An unbiased evaluation of environment management and packaging tools) blog post](images/pip_tools_venn_diagram.png){width="70%"}

## Ferramentas{.smaller}

![Diagrama de Venn](images/package_management.png){width="66%"}

## Muitas opções, um só caminho

![Eu só quero instalar meu pacote e suas dependências!](images/too-many-options.webp)

## Pip

- Gerenciador comum ao Python, já vem com a linguagem
- `pip install algum-pacote-do-pypi`
- `pip install -e .[dev]`
- `pip install -r requirements.txt`

## Pip

Quem resolve as dependências das minhas dependências?

::: {.columns}

:::{.column}
```{mermaid}
graph TD
    my_app["My App (0.1.0)"] --> my_django["My Django (0.1.0)"]
    my_django --> my_requests["My Requests (0.1.0)"]
    style my_requests fill:#bbf
```
:::


:::{.column}
```{mermaid}
graph TD
    my_app["My App (0.1.0)"] --> my_django["My Django (0.1.0)"]
    my_django --> my_requests["My Requests (1.0.0)"]
    style my_requests fill:#f9f
```
:::

:::

- `cd my_app`
- `pip install -r requirements`
- Bump my_requests e mude o código

## Pip

Como garantir a reprodutibilidade do meu app e garantir o meu sextou sem incidentes?

## Lock files

- Arquivos que armazenam todas as dependencias
    - Garante reprodutibilidade
    - Acelera a resolução das dependencias (instalação mais rápida)
    - Aumenta a segurança da aplicação (supply chain)
    - Aumenta as chances de um sextou

## Lock files

- Como?
  - Pin de versões dos pacotes e os pacotes dos pacotes...
  - Artifact hashing para checar se o hash do download atual é o mesmo do arquivo .lock

## Lock files

```toml
# This file is automatically @generated by Poetry 2.1.2 and should not be changed by hand.

[[package]]
name = "my-django"
version = "0.1.0"
description = ""
optional = false
python-versions = ">=3.11"
groups = ["main"]
files = []
develop = false

[package.dependencies]
my-requests = {path = "/home/italo/open/avaliando-gerenciadores-de-pacotes-python/my_requests"}

[package.source]
type = "directory"
url = "../my_django"

[[package]]
name = "my-requests"
version = "0.1.0"
description = "A small example package"
optional = false
python-versions = ">=3.11"
groups = ["main"]
files = []
develop = false

[package.source]
type = "directory"
url = "../my_requests"

[metadata]
lock-version = "2.1"
python-versions = ">=3.11"
content-hash = "1d764e747213e8779e07b8c557a61041ff0f606c9d7675f6d4c8fcccc79009d6"
```

## Posso usar `pip freeze > requirements.txt`?

- Remover/atualizar pacotes não garante que suas dependencias serão removidas do requirements.txt
- Não tem capacidade de resolver problemas de diferentes versões (conflitos)
  - Pacote A -> requests>=1.0.0
  - Pacote B -> requests>=1.2.0

## Se lock de dependências é tão legal por que o pip não tem um?

- 2016 - [PEP 518 – Specifying Minimum Build System Requirements for Python Projects](https://peps.python.org/pep-0518/) - setup.py/config.cfg -> pyproject.toml
- 2021 - [PEP 665 – A file format to list Python dependencies for reproducibility of an application](https://peps.python.org/pep-0665/) - Rejeitado
- 2025 - [PEP 751 – A file format to record Python dependencies for installation reproducibility](https://peps.python.org/pep-0751/) - Aceito

::: {.notes}
Python é uma linguagem sem dono, nós somos donos delas e podemos propôr melhorias.

O ecossistema de pacotes python vem melhorando a anos, em 2016 saímos dos confusos setup.py para um formato pyproject.toml mais estruturado.
A PEP 518 deixou em aberto um [build-system] e [tool.] para permitir maior flexibilidade de uso, devido ao contexto variado de construção de pacotes.
Em 2021 veio uma das primeiras propostas de um formato de lock, que foi rejeitado.
:::

## Pipenv

::: {.columns}

::: {.column width="30%"}
![](images/pipenv.png)
:::

::: {.column width="70%"}
- Cria automaticamente `Pipfile` e `Pipfile.lock`
- Instala corretamente a versão do Python (via Pyenv)
- Automaticamente cria `virtualenv`
- Automaticamente carrega `.env`
- Não segue o padrão python `pyproject.toml`

:::

:::

## Poetry

- "Sucessor" do Pipenv
- `poetry.lock`
- Não segue a [PEP 621 - Storing project metadata in pyproject.toml](https://github.com/python-poetry/roadmap/issues/3)
- Além das capacidades do pipenv, também publica pacotes

## PDM

- Similar ao Poetry, mas segue todas as PEPs

## Rye

- Pacote em fase experimental do criador do Flask

## Pip-tools

- `python -m piptools compile` usa um requirements.in e gera
requirements.txt com todas as dependências pinadas
- `python -m piptools sync`
- `python -m piptools update`

## Comparação

- Durante as discussões do `AI & Data` levantamos algumas necessidades:
  - Queremos ter um lock (reprodutibilidade)
  - Queremos usar uma ferramenta madura
  - Preferimos seguir as PEPs do Python
  - Preferimos uma ferramenta com baixa curva de aprendizado
- Opções: pipenv, poetry e pip-tools

## Comparação

![Popularidade das ferramentas](images/star-history-2024426.png)

## Comparação

| Ferramenta  | cross-platform | integração com env atual | curva de aprendizado | Manutenção |
|--------|--------|--------|--------|
| poetry  | ✅ | ❌ (padrão próprio) | Razoável | ✅ |
| pip-tools   | ❌ (pip-compile-cross-platform) | ✅ | Pequena | ✅ |
| pipenv | ✅❌ | ❌ (Pipfile vs Pyproject.toml) | Razoável | ✅❌ |

## Por que não utilizar o Pipenv?

- Já foi [abandonado uma vez](https://github.com/pypa/packaging.python.org/issues/701) (credibilidade)
- Resolução de conflitos já foi um problema no passado (talvez ainda seja lento)
- Não segue a estrutura pyproject.toml sugerida pelas PEPs
- Além de instalar os pacotes cria a virtualenv (mais do que precisamos)

## Por que não utilizar o pip-tools?

- Problemas de geração de lock files cross-platform:
  - Cada plataforma precisaria de um requirements.in diferente

## Poetry

- Não segue a estrutura pyproject.toml sugerida pelas PEPs
- Além de instalar os pacotes, criar a virtualenv, também publica os pacotes
(mais do que precisamos)
- No time de AI & Data não usariamos a virtualenv, continuaríamos usando pyenv,
venv e rodaríamos o `poetry install`, `poetry add some-dep`, `poetry update`

## Conda e mamba

- Criados para projetos de data science
- Gerenciam além da instalação dos pacotes python, como dependencias do sistema (ex. CUDA)
- Existe a possibilidade de usar [conda + poetry](https://michhar.github.io/2023-07-poetry-with-conda/)
- Conda e mamba não tem .lock por default, usam `conda-lock`
- Mamba é mais rápido na resolução de pacotes e uso com docker

## Uso das ferramentas

- `pip-compile --generate-hashes --output-file=requirements.txt requirements.in`
- `poetry add requests`
- uv pip un/install requests
  - `uv pip compile --generate-hashes pyproject.toml -o requirements.txt`
  - `uv pip compile --generate-hashes requirements.in -o requirements.txt`

## Conclusão

- Lock de dependências em Python ainda é uma questão em aberto, com PEP encaminhada
- Dentre as ferramentas investigadas: Poetry e pip-tools são
  soluções maduras que atendem nossos requisitos
- uv tem sido experimentada nos últimos meses e sua velocidade vem intrigando o time a iniciar sua adoção

## Referências {.smaller}

- [An unbiased evaluation of environment management and packaging tools](https://alpopkes.com/posts/python/packaging_tools/)
- [Como poetry usa .lock cross platform](https://discuss.python.org/t/insights-into-how-poetry-lock-works-cross-platform/17846/30)
- [Python packaging user guide](https://packaging.python.org/en/latest/guides/tool-recommendations/)
- [PEP 665 lock file rejeitada](https://peps.python.org/pep-0665/)
- [PEP 751 – A file format to record Python dependencies for installation reproducibility](https://peps.python.org/pep-0751/)
- [Faster conda install](https://pythonspeed.com/articles/faster-conda-install/)

![Github com apresentação](images/github-repo.svg)
